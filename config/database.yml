# PostgreSQL config for Rails (Docker)
# Uses DATABASE_URL everywhere so we always connect over TCP to the "db" service.

default: &default
  adapter: postgresql
  encoding: unicode
  pool: <%= ENV.fetch("RAILS_MAX_THREADS", 5) %>

development:
  <<: *default
  # Fallback points to the docker "db" service; override with DATABASE_URL if you want.
  url: <%= ENV.fetch("DATABASE_URL", "postgres://postgres:#{ENV.fetch('POSTGRES_PASSWORD', 'password')}@db:5432/library_backend_development") %>

test:
  <<: *default
  url: <%= ENV.fetch("DATABASE_URL", "postgres://postgres:#{ENV.fetch('POSTGRES_PASSWORD', 'password')}@db:5432/library_backend_test") %>

production:
  # Always use DATABASE_URL in production. Do NOT specify host/port/user/password separately,
  # or Rails may fall back to a local Unix socket.
  <% base_url = ENV['DATABASE_URL'] || "postgres://postgres:#{ENV.fetch('POSTGRES_PASSWORD', 'password')}@db:5432/library_backend_production" %>
  primary: &primary_production
    <<: *default
    url: <%= base_url %>
    variables:
      statement_timeout: 15000

  # Derive additional databases by swapping the DB name in the URL.
  <% def url_with_db(url, db_name); url.sub(%r{/[^/]+$}, "/#{db_name}"); end %>
  cache:
    <<: *primary_production
    url: <%= url_with_db(base_url, "library_backend_production_cache") %>
    migrations_paths: db/cache_migrate

  queue:
    <<: *primary_production
    url: <%= url_with_db(base_url, "library_backend_production_queue") %>
    migrations_paths: db/queue_migrate

  cable:
    <<: *primary_production
    url: <%= url_with_db(base_url, "library_backend_production_cable") %>
    migrations_paths: db/cable_migrate
